#ifndef DUNE_PDELAB_BASIS_ORDERING_ENTITY_BASE_HH
#define DUNE_PDELAB_BASIS_ORDERING_ENTITY_BASE_HH

#include <dune/pdelab/common/multiindex.hh>
#include <dune/pdelab/common/tree_traversal.hh>
#include <dune/pdelab/common/container_entry.hh>

#include <dune/pdelab/concepts/multiindex.hh>
#include <dune/pdelab/concepts/treenode.hh>
#include <dune/pdelab/concepts/indexable.hh>

#include <dune/typetree/treepath.hh>
#include <dune/typetree/childextraction.hh>

#include <dune/localfunctions/common/interfaceswitch.hh>
#include <dune/localfunctions/common/localkey.hh>

#include <dune/geometry/type.hh>
#include <dune/geometry/typeindex.hh>
#include <dune/geometry/referenceelements.hh>

#include <vector>
#include <numeric>

namespace Dune::PDELab::inline Experimental::Impl {

/**
 * @brief Ordering of entity degrees of freedom
 * This class is in charge to map a degree of freedom within an entity to a
 * multi-index. Such mapping is injective with respect to a specific entity,
 * in particular, the resulting multi-indices start from 0. For example, an
 * entity with 3 degrees of freedom may be mapped into (0), (1), and (2),
 * or into (0,0), (1,0), and (1,1) for a ordering of two children and blocked
 * structure.
 *
 * The mapping is constructed in a bottom-up fashion.
 * First, the leaf node extract an ordering based on a local finite element
 * for each entity (see LocalCoefficients and LocalKey objects from
 * dune-localfunctions). The resulting ordering for leaf nodes is guarnteed to
 * be consequitive with 0-based indexation, i.e. an entity that has 3 DOFs
 * associated with it, will alywas map their local keys into (0), (1) and (2).
 * This requirement is important in order to provide fast mappings for DG
 * spaces! Second, a parent node compose its children indices with respect to a
 * merging strategy. For example, a blocked strategy consists on prefixing the
 * child index into the child indices.
 *
 * In particular, the complexity on the implementation of this object comes
 * from the fact that the offsets for every entity in an entity set are stored
 * as contiguously as possible and using many information at compile time
 * whenever possible.
 *
 * The most important part to understand on this class are the
 * `firstContainerIndex` and `containerSize` methods. See their documentation
 * first. All the rest of this class turns around the data structures used in
 * there.
 *
 * This local map is the used to construct a global map that takes into account the
 * whole grid, in other words, a set of maps where each entity maps to a uniquely
 * different multi-index (which is the countrary of this class where each
 * entity is individually mapped and the result is not necessarily unique)
 * @see EntitySetOrderingNode.
 *
 * The mappings produced by this class is almost dense. The cases where the
 * map is not dense is where blocked structure induces a multi-index whose
 * suffix has a 0-size range on the last index. This happens when there is at
 * least one blocking merging strategy within the tree and the finite elements
 * of the different leaf nodes cover different codimensions. An example of
 * this case is taylorhood elements of degree 1 where all nodes are entity
 * ordered with blocked merged strategy: The root node will provide the whole
 * tree suffix to the multi-index (because of the blocked strategy) but the
 * children node corresponding to the pressure element have no DOFs in the
 * facets of the elements.
 *
 * @note Order of multi-indices: The indices generated by this map follow a
 * top to bottom ordering, meanig that lefttmost indices indicate a tree-path
 * from the upper part of a tree of indices, while rightmost indices indicate
 * lower parts on the tree. This is consistent with dune-functions and countrary
 * to PDELab orderings.
 *
 * @todo Compile-time check whether dense ordering is guaranteed
 * @todo Avoid repeated update on vector spaces_gt_dof_offsets
 * @todo Create an abrstraction for the offset vectors. Raw managment of them
 * has proven to be error prone and hard to mantain.
 *
 * @tparam Node   A typetree node using that inherits this class (Barton–Nackman trick)
 * @tparam MS     A merging strategy
 */
template<class Node, class MS>
class EntityOrderingNode
{
  // Notice that by this point `Node` is an incomplete type because it will only
  // be completed after inheriting from this class (Barton–Nackman trick)
  // Therefore, we can only inquiry its contents after completion, which
  // is why we only deduce types on functions and not in the class scope.

  // the type to export multi-indices
  using SizeType = typename MS::SizeType;
  // the type for bitset information of codimensions used
  using CodimFlag = typename MS::CodimFlag;
  // the type for entitysets
  using EntitySet = typename MS::EntitySet;
  // a key value to identify geometry types that are not mapped by this class
  static constexpr SizeType GT_UNUSED = std::numeric_limits<SizeType>::max();

  // We share private methods with other nodes of the same kind. This allows
  // to have algorithms in one templated class and still keep internals
  // encapsulated to the outside.
  // But with great power comes great responsability:
  //   DO NOT MODIFY OTHER NODE PRIVATE MEMBERS!
  //   Otherwise code becomes -more- unmaintainable and harder to reason about
  //   instead create a function that describes the performed action
  template<class Node_, class MS_>
  friend class EntityOrderingNode;

public:
  using MergingStrategy = MS;

  EntityOrderingNode(const MergingStrategy& merging_strategy)
    : _merging_strategy{ merging_strategy }
    , _fixed_size{ prioryFixedSize() }
    , _fixed_size_possible{ true }
  {
    // all the entity sets below this node shall be the equal to each other
    if constexpr (std::equality_comparable<EntitySet>)
      forEachLeafNode(node(), [&](auto& leaf, auto path) {
        assert(entitySet() == leaf.entitySet());
      });

    // in case of vector space (same underlying discrete-function-space), enable
    // sharing states in children nodes
    if constexpr (Concept::ArrayTreeNode<Node> ||
                  Concept::VectorTreeNode<Node>) {
      if (node().degree() > 0) {
        // compare other nodes to the first one
        const auto& model_node = node().child(0);
        bool vector_space = true;
        forEachLeafNode(model_node, [&](auto& leaf_node, auto& path) {
          for (std::size_t i = 1; i < node().degree(); ++i)
            vector_space &=
              (leaf_node.space() ==
               PDELab::containerEntry(node().child(i), path).space());
        });
        // if discrete-function-space was equal everywhere, reuse storage of
        // children
        if (vector_space)
          for (std::size_t i = 1; i < node().degree(); ++i)
            node().childStorage(i) = node().childStorage(0);
      }
    }
  }

  EntityOrderingNode(const EntityOrderingNode&) = delete;
  EntityOrderingNode(EntityOrderingNode&&) = default;

  // Check if all leaf nodes have the same fixed DOF size per geometry type at compile time
  [[nodiscard]] static consteval auto prioryFixedSize()
  {
    if constexpr (Concept::LeafTreeNode<Node>) {
      // base case: query information from finite element map
      return Node::commonSizePerGeometryType().has_value();
    } else if constexpr (Concept::ArrayTreeNode<Node> ||
                         Concept::VectorTreeNode<Node>) {
      // all children have the same type so we inherit their fixed size
      return Node::ChildType::prioryFixedSize();
    } else {
      // make a conjunction of all the children types
      static_assert(Node::isComposite);
      auto unfold_children = [&](auto... i) {
        constexpr bool all_fixed_size =
          (TypeTree::template Child<Node, i>::prioryFixedSize() && ...);
        return std::integral_constant<bool, all_fixed_size>{};
      };
      auto indices = std::make_index_sequence<Node::degree()>{};
      return unpackIntegerSequence(unfold_children, indices);
    }
  }

  // Gives the maximum size of a prefix produced by this ordering
  [[nodiscard]] static consteval std::size_t maxContainerDepth()
  {
    if constexpr (Concept::LeafTreeNode<Node>) {
      return 1;
    } else {
      auto child_depth = [&]() {
        if constexpr (Concept::ArrayTreeNode<Node> ||
                      Concept::VectorTreeNode<Node>) {
          return Node::ChildType::maxContainerDepth();
        } else {
          static_assert(Node::isComposite);
          return unpackIntegerSequence(
            [](auto... i) {
              return std::max({
                TypeTree::template Child<Node, i>::maxContainerDepth()...});
            },
            std::make_index_sequence<Node::degree()>{});
        }
      }();
      if constexpr (containerBlocked())
        return child_depth + 1;
      else
        return child_depth;
    }
  }

  // Check if this ordering has fixed DOF size per geometry type
  [[nodiscard]] auto fixedSize() const noexcept
  {
    if constexpr (prioryFixedSize())
      return std::true_type{};
    else
      return _fixed_size;
  }

  // Entity set of the ordering
  [[nodiscard]] const auto& entitySet() const noexcept
  {
    return _merging_strategy.entitySet();
  }

  // Entity set of the ordering
  [[nodiscard]] auto& entitySet() noexcept
  {
    return _merging_strategy.entitySet();
  }

  // Check if a given geometry type is mapped to multi-indices within this map
  [[nodiscard]] bool containsGeometry(SizeType gt_index) const noexcept
  {
    return _gt_used[gt_index];
  }

  // Check if a given geometry type is mapped to multi-indices within this map
  [[nodiscard]] bool containsGeometry(const GeometryType& gt) const noexcept
  {
    return containsGeometry(GlobalGeometryTypeIndex::index(gt));
  }

  // Check if a given codimension is mapped to multi-indices within this map
  [[nodiscard]] bool containsCodim(SizeType codim) const noexcept
  {
    return codimClosure().test(codim);
  }

  // Gives a bitset of the codimenions that this class is able to map
  [[nodiscard]] CodimFlag codimClosure() const noexcept
  {
    assert(maxCodimCount() >= _codim_used.count());
    return _codim_used;
  }

  // Check if DOFs only exist in one codimension
  //! @note This feature is really important. If true, all the multi-indices
  // can be constructed from the container index suffix and the block count of
  // a given tree (i.e. no need of local keys of the reference local element).
  [[nodiscard]] auto singleCodim() const noexcept
  {
    if constexpr (maxCodimCount() == 1)
      return std::true_type{};
    else
      return (_codim_used.count() == 1);
  }

  // Check if DOFs are only attached to the volume part of the entities.
  // If true, it should hint to DG and FV spaces.
  [[nodiscard]] auto disjointCodimClosure() const noexcept
  {
    if constexpr (maxCodimCount() == 1)
      return std::integral_constant<bool, mayContainCodim(Indices::_0)>{};
    else
      return (_codim_used.count() == 1 and _codim_used[0]);
  }

  // Maximum number of coefficients that may be associated to a local space
  [[nodiscard]] SizeType maxLocalCount() const noexcept
  {
    return _max_local_coeff_count;
  }

  // Number of blocks associated to a given entity
  [[nodiscard]] auto blockCount(const SizeType gt_index,
                                const SizeType entity_index) const noexcept
  {
    if constexpr (containerBlocked()) {
      static_assert(not Concept::LeafTreeNode<Node>);
      return node().degree();
    } else {
      assert(containsGeometry(gt_index));
      if (fixedSize())
        return SizeType{ blockCount(gt_index) };

      if constexpr (Concept::LeafTreeNode<Node>) {
        return (*_entity_dof_offsets)[((*_gt_entity_offsets)[gt_index] +
                                       entity_index)];
      } else {
        const auto degree = node().degree();
        return (*_entity_dof_offsets)[((*_gt_entity_offsets)[gt_index] +
                                       entity_index) *
                                        degree +
                                      degree - 1];
      }
    }
  }

  // number of blocks associated to a given entity (fixed size version)
  [[nodiscard]] auto blockCount(std::size_t gt_index) const noexcept
  {
    assert(fixedSize());
    if constexpr (containerBlocked()) {
      static_assert(not Concept::LeafTreeNode<Node>);
      return node().degree();
    } else {
      if constexpr (Concept::LeafTreeNode<Node>) {
        return (*_gt_dof_offsets)[gt_index];
      } else {
        const auto degree = node().degree();
        return (*_gt_dof_offsets)[gt_index * degree + degree - 1];
      }
    }
  }

  // print offsets to debug orderings...
  void debugInfo() const {
    using FEM = typename Node::Space::Traits::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

    std::cout << "Fixed Size per Geometry Type: " << bool(fixedSize()) << "\n";
    std::cout << "Blocked: " << bool(containerBlocked()) << "\n";
    if (fixedSize())
      std::cout << "  # Geometry Type, DOF Count\n";
    else
      std::cout << "  # Geometry Type, Entity Index, DOF Count ==\n";

    assert(Concept::LeafTreeNode<Node>); // TODO implement other nodes...
    for (std::size_t codim = fem_codim; codim <= EntitySet::dimension; ++codim) {
      for (const auto& gt : entitySet().indexSet().types(codim)) {
        const auto gt_index = GlobalGeometryTypeIndex::index(gt);
        if (fixedSize()) {
          std::cout << "  " << gt << ", " << blockCount(gt_index) << " \n";
        } else {
          auto gt_begin = begin(*_gt_entity_offsets) + gt_index;
          auto size = *(gt_begin+1) - *gt_begin;
          for (std::size_t i = 0; i != size; ++i)
            std::cout << "  " << gt << ", " << i << ", " << (*_entity_dof_offsets)[i + *gt_begin] << "\n";
        }
      }
    }
  }


  // total number of blocks for this node on all entities
  [[nodiscard]] auto blockCount() const noexcept
  {
    if constexpr (containerBlocked()) {
      static_assert(not Concept::LeafTreeNode<Node>);
      return node().degree();
    } else {
      return _block_count;
    }
  }

  // counts the number of blocks in the leaf nodes
  [[nodiscard]] SizeType dimension() const noexcept
  {
    SizeType dof_count = 0;
    forEachLeafNode(
      node(), [&](auto& leaf, auto path) { dof_count += leaf.blockCount(); });
    return dof_count;
  }

  /**
   * @brief Gives a container prefix (Outer2Inner) for a particular entity and leaf node of the
   * tree. The resulting multi-index suffix contains the mapping for the first
   * DOF on the leaf node and entity. Due to the guarantees of this class,
   * this is enough information to form all of the other DOFs associated for
   * this entity. In particular, is only necessary to accumulate front the
   * local key of the finite element in order to obtain a desired container
   * index.
   * @note If disjointCodimClosure() is true, the whole range of indices for
   * this entity may be obtained by accumulating back in range of
   * [ 0, blockCount(gt_index, entity_index) ).
   *
   * @tparam CompositionSuffix      Type for a treepath (typicaly MultiIndex)
   * @param comp_suff               Path to the required leaf node
   * @param gt_index                Index of the geometry type
   * @param entity_index            Index of the entity
   * @return Concept::MultiIndex    A Outer2Inner prefix to the first container multi-index
   */
  template<Concept::MultiIndex CompositionSuffix>
  [[nodiscard]] Concept::MultiIndex auto firstContainerIndex(
    CompositionSuffix comp_suff,
    SizeType gt_index,
    SizeType entity_index) const noexcept
  {
    // Note: Multi-index is read Outer->Inner
    // only map known geometry indices
    assert(containsGeometry(gt_index));
    if constexpr (Concept::LeafTreeNode<Node>) {
      // (end of recursion) in case of leaf node. The fist multi-index is
      // guaranteed to be (0)
      static_assert(CompositionSuffix::size() == 0);
      return TypeTree::treePath(SizeType{ 0 });
    } else {
      static_assert(CompositionSuffix::size() > 0);
      const auto child = front(comp_suff);
      // (continue recursion) get container index of the child node.
      const auto cont_prefix = node().child(child).firstContainerIndex(
        pop_front(comp_suff), gt_index, entity_index);
      if constexpr (containerBlocked()) {
        // blocked merging: simply push front the child index
        return push_front(cont_prefix, child);
      } else {
        SizeType offset = 0;
        // lexicopgraphic merging: accumulate front the offest of the (child-1)
        if (child != 0) {
          if (fixedSize()) {
            offset = (*_gt_dof_offsets)[gt_index * node().degree() + child - 1];
          } else {
            const auto index =
              ((*_gt_entity_offsets)[gt_index] + entity_index) *
                node().degree() +
              child - 1;
            offset = (*_entity_dof_offsets)[index];
          }
        }
        return accumulate_front(cont_prefix, offset);
      }
    }
  }

  // Check if the resulting container is blocked at this node level
  [[nodiscard]] static constexpr auto containerBlocked()
  {
    // the blocking structure of a local space is given by the tag of its
    // children
    if constexpr (Concept::LeafTreeNode<Node>) {
      return std::false_type{};
    } else if constexpr (Concept::ArrayTreeNode<Node> ||
                         Concept::VectorTreeNode<Node>) {
      constexpr bool child_blocked = Node::ChildType::MergingStrategy::Blocked;
      return std::integral_constant<bool, child_blocked>{};
    } else if constexpr (Concept::TupleTreeNode<Node>) {
      auto unfold_children = [&](auto... i) {
        constexpr bool any_blocked =
          (TypeTree::template Child<Node, i>::MergingStrategy::Blocked || ...);
        constexpr bool all_blocked =
          (TypeTree::template Child<Node, i>::MergingStrategy::Blocked && ...);
        static_assert(all_blocked == any_blocked,
                      "All static children of a Space grouped "
                      "by entity must have the same blocking requirements");
        return std::integral_constant<bool, any_blocked>{};
      };
      auto indices = std::make_index_sequence<Node::degree()>{};
      return unpackIntegerSequence(unfold_children, indices);
    } else {
      static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
    }
  }

  /**
   * @brief Gives the total number of indices for any suffix of the mapped
   * multi-indices
   * @details Any suffix of a container index generated by this object
   * (constructed from `firstContainerIndex`) indices a size. Such size refers
   * to the range of suffixes on the next level of multi-indices. For example,
   * if a node tree is able to generate the following Inner2Outer multi-indices
   * for a given entity (0,0,0), (0,1,0), ..., (0,10,0), then the suffix (-,-,0)
   * induces a size of 11 while (-,0,0), (-,1,0), etc. induce all a size of 1.
   *
   * @tparam ContainerSuffix  The type of a sufix (typically a PDELab::MultiIndex)
   * @param cs                A suffix of a Outer2Inner multi-index contained by this map
   * @param gt_index          Index of the geometry type
   * @param entity_index      Index of the entity
   * @return std::size_t      The size induced by the multi-index suffix
   */
  template<Concept::MultiIndex ContainerSuffix>
  [[nodiscard]] std::size_t containerSize(const ContainerSuffix& cs,
                                          SizeType gt_index,
                                          SizeType entity_index) const noexcept
  {
    // Note: Multi-index is read Inner->Outer
    // transform to reserved multi-index to avoid problems on pop back
    auto rcs = MultiIndex<SizeType, maxContainerDepth()>{ cs };
    // suffix wants the size for this node
    if (rcs.size() == 0)
      return node().blockCount(gt_index, entity_index);

    if constexpr (Concept::LeafTreeNode<Node>) {
      assert(rcs.size() == 1);
      return 0; // Leaf nodes contain no more indices
    } else {

      // helper to return from any child with a dynamic child index
      auto childContainerSize = [&](std::size_t child_i,
                                    auto next_suffix) -> SizeType {
        if constexpr (Concept::ArrayTreeNode<Node> ||
                      Concept::VectorTreeNode<Node>) {
          return node().child(child_i).containerSize(
            next_suffix, gt_index, entity_index);
        } else {
          static_assert(Concept::TupleTreeNode<Node>);
          // at this point we recoverd the index, but there is no way to
          // propagate its static information outside of this function (i.e. a
          // return type that depends on the child index)
          SizeType _size = std::numeric_limits<SizeType>::max();
          // make a loop over all nodes and check which one matches the child
          // index
          forEach(node(), [&](auto& child, auto i) {
            if (i == child_i)
              _size = child.containerSize(next_suffix, gt_index, entity_index);
          });
          return _size;
        }
      };

      // the next index to find out its size
      auto back_index = back(rcs);
      // task: find child the child node for whom this index corresponds
      if constexpr (containerBlocked()) {
        // easy case, the back_index is exactly the index of the child node
        return childContainerSize(back_index, pop_back(rcs));
      } else {
        // here we need to "recover" the child index that describes the
        // back_index (inverse of firstContainerIndex operation)
        assert(_gt_used[gt_index]);
        auto dof_begin =
          begin(fixedSize() ? *_gt_dof_offsets : *_entity_dof_offsets);
        if (fixedSize())
          dof_begin += gt_index * node().degree();
        else
          dof_begin +=
            ((*_gt_entity_offsets)[gt_index] + entity_index) * node().degree();
        auto dof_end = dof_begin + node().degree();
        auto dof_it = std::upper_bound(dof_begin, dof_end, back_index);
        auto next = accumulate_back(rcs, SizeType{ 0 });
        if (dof_it != dof_begin) {
          std::advance(dof_it, -1);
          assert(back(cs) >= *dof_it);
          next = accumulate_back(next, -(*dof_it));
        }
        std::size_t child_index = std::distance(dof_begin, dof_it);
        assert(node().degree() > child_index);
        return childContainerSize(child_index, next);
      };
    }
  }

  // this method needs be called only on the root node of the local space
  // tree the fixed and variable size updates propagate their calls down the
  // tree. In particular, this produces a depth first algorithm. Before every
  // node: Allocate and set-up node. Before/After children: Carry partial
  // calculation of the children sizes After every node: Calculate final sizes
  // of children and accumulate to obtain offets.
  void update()
  {
    // if constexpr (Dune::Concept::MutableEntitySet<EntitySet,0>) {
    //   entitySet().addCodim(0); // we always need cells
    //   const std::size_t dim = EntitySet::dimension;
    //   auto codim_range = std::make_index_sequence<dim + 1>{};

    //   Dune::Hybrid::forEach(codim_range, [&](auto codim) {
    //     if (mayContainCodim(codim))
    //       entitySet().addCodim(codim);
    //   });

    //   entitySet().update();
    // }

    updateFixedSizeOrderings();
    if (not prioryFixedSize())
      updateVariableSizeOrderings();
  }

protected:
  // A priory compile-time information if a given codimension may contain DOFs wrt a grid entity
  // If false, there is a guarantee that this map will never contain such a
  // codimension. If true, codimension may or may not be used at run-time
  template<class EntityCodim>
  [[nodiscard]] static constexpr auto mayContainCodim(EntityCodim entity_codim)
  {
    if constexpr (Concept::LeafTreeNode<Node>) {
      constexpr std::size_t entity_dim = EntitySet::dimension - entity_codim;
      // dimension of the finite element domain (perhaps embedded on sub entities)
      using FEM = typename Node::Space::Traits::FiniteElementMap;
      constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
      if constexpr (entity_dim > fem_dim) {
        // requested dim is higher than the finite element dimension thus not contained
        return std::false_type{};
      } else if constexpr (requires { FEM::hasDOFs(int{}); }) {
        // in this case we can check if a DOF is included or not
        constexpr std::size_t fem_codim = fem_dim - entity_dim;
        constexpr bool has_dofs = FEM::hasDOFs(static_cast<int>(fem_codim));
        return std::integral_constant<bool, has_dofs>{};
      } else {
        return std::true_type{};
      }
    } else if constexpr (Concept::ArrayTreeNode<Node> ||
                         Concept::VectorTreeNode<Node>) {
      return Node::ChildType::mayContainCodim(entity_codim);
    } else if constexpr (Node::isComposite) {
      auto unfold_children = [&](auto... i) {
        constexpr bool has_dofs =
          (TypeTree::template Child<Node, i>::mayContainCodim(entity_codim) || ...);
        return std::integral_constant<bool, has_dofs>{};
      };
      auto indices = std::make_index_sequence<Node::degree()>{};
      return unpackIntegerSequence(unfold_children, indices);
    } else {
      static_assert(Dune::AlwaysFalse<Node>{}, "Not known Node Type");
    }
  }

private:
  //! Compile-time information of maximum codimensions used by this map
  //! @note Notice that less codimenions may be actually used at run-time
  [[nodiscard]] static auto constexpr maxCodimCount()
  {
    auto sequence = std::make_index_sequence<1 + EntitySet::dimension>{};

    constexpr std::size_t count = Dune::unpackIntegerSequence(
      [&](auto... codim) {
        constexpr std::size_t one{ 1 }, zero{ 0 };
        return ((EntityOrderingNode::mayContainCodim(codim) ? one : zero) +
                ...);
      },
      sequence);
    return std::integral_constant<std::size_t, count>{};
  }

  //! Setup ordering for fixed size maps
  //! @note Recursive function, only call this from root node.
  void updateFixedSizeOrderings()
  {

    const std::size_t dim = EntitySet::dimension;

    _fixed_size = prioryFixedSize();
    _max_local_coeff_count = 0;
    _block_count = 0;

    if constexpr (prioryFixedSize()) {
      // reset falgs and offsets
      _codim_used.reset();
      const auto gt_count = GlobalGeometryTypeIndex::size(dim);
      _gt_used.assign(gt_count, false);
      if (not _gt_dof_offsets)
        _gt_dof_offsets = std::make_unique<std::vector<SizeType>>();
      _gt_dof_offsets->assign(
        gt_count * std::max<std::size_t>(1, node().degree()), 0);
    }

    // fill out flags and offsets depending on the node type
    if constexpr (Concept::LeafTreeNode<Node>) {

      using FEM = typename Node::Space::Traits::FiniteElementMap;
      constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
      constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

      if constexpr (prioryFixedSize()) {
        for (std::size_t codim = fem_codim; codim <= EntitySet::dimension; ++codim) {
          for (const auto& gt : entitySet().indexSet().types(codim)) {
            SizeType size = node().space().finiteElementMap().size(gt);
            const auto gt_index = GlobalGeometryTypeIndex::index(gt);
            (*_gt_dof_offsets)[gt_index] = size;
            _gt_used[gt_index] = size > 0;
            _block_count += size * entitySet().size(gt);
            assert(codim == dim - gt.dim());
            _codim_used[codim] = _codim_used[codim] or (size > 0);
          }
        }
        // collect max entity sides on fem dimension for an entity of codimension 0
        int max_sub_entities = 0;
        for (const auto& gt : entitySet().indexSet().types(0)) {
          using Dune::referenceElement;
          auto ref_el = referenceElement<double, EntitySet::dimension>(gt);
          max_sub_entities = std::max(max_sub_entities, ref_el.size(EntitySet::dimension - fem_dim));
        }
        node().setMaxSubEntities(max_sub_entities);
        _max_local_coeff_count = max_sub_entities * node().space().finiteElementMap().maxLocalSize();
      }
    } else {
      forEach(node(), [&](auto& child, auto i) {
        // first, set up child gt collection
        child.updateFixedSizeOrderings();
        // then, accumulate child results to this node
        if constexpr (prioryFixedSize()) {
          // this node can only be fixed size if child is also fixed size
          assert(child.prioryFixedSize());

          // properties contained in child nodes are also contained here
          for (std::size_t codim = 0; codim <= dim; ++codim)
            _codim_used[codim] =
              _codim_used[codim] or child.containsCodim(codim);

          for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
            _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);

          _max_local_coeff_count += child.maxLocalCount();

          if (not containerBlocked())
            _block_count += child.blockCount();

          // get size of child nodes
          for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
            (*_gt_dof_offsets)[gt * node().degree() + i] =
              child.blockCount(gt);
        }
      });
    }

    if constexpr (prioryFixedSize()) {
      // finally, convert child gt sizes into offsets
      auto it = begin(*_gt_dof_offsets);
      const auto advance = std::max<std::size_t>(1, node().degree());
      while (it != end(*_gt_dof_offsets))
        it = std::partial_sum(it, it + advance, it);
    }
  }

  //! Pre-allocate objects on this node related to the variable size ordering
  void allocateVariableSizeOrdering()
  {
    static_assert(not prioryFixedSize());
    _codim_used.reset();
    const auto gt_count = GlobalGeometryTypeIndex::size(EntitySet::dimension);
    _gt_used.assign(gt_count, false);

    if (not _gt_dof_offsets)
      _gt_dof_offsets = std::make_unique<std::vector<SizeType>>();
    _gt_dof_offsets->assign(
      gt_count * std::max<std::size_t>(1, node().degree()), GT_UNUSED);

    if (not _gt_entity_offsets)
      _gt_entity_offsets = std::make_unique<std::vector<SizeType>>();
    _gt_entity_offsets->assign(gt_count + 1, 0);
  }

  //! Collect used geometry types on leaf nodes (variable size)
  template<class Entity>
  void collectLeafGeometryTypes(const Entity& entity)
  {
    static_assert(not prioryFixedSize());
    static_assert(Concept::LeafTreeNode<Node>);
    static_assert(Dune::Concept::EntityExtended<Entity>);
    assert(not fixedSize());

    using FEM = typename Node::Space::Traits::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

    const FEM& fem = node().space().finiteElementMap();
    std::size_t max_coeff_count = 0;
    for (const auto& sub_entity : subEntities(entity, Dune::Codim<fem_codim>{})) {
      const auto& finite_element = fem.find(sub_entity);
      using FEM = typename Node::Space::Traits::FiniteElementMap;
      using FESwitch = FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
      const auto& coeffs = FESwitch::coefficients(finite_element);
      max_coeff_count += coeffs.size();

      const auto& ref_el = referenceElement(sub_entity.geometry());
      for (std::size_t i = 0; i < coeffs.size(); ++i) {
        const auto& key = coeffs.localKey(i);
        auto gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
        _gt_used[gt_index] = true;
        _codim_used.set(fem_codim + key.codim());
      }
    }
    _max_local_coeff_count = std::max<std::size_t>(_max_local_coeff_count, max_coeff_count);
    node().setMaxSubEntities(std::max<int>(node().maxSubEntities(), entity.subEntities(fem_codim)));
  }

  //! Collect geometry types for all nodes (variable size)
  //! @note Use after every leaf node called `collectLeafGeometryTypes`
  //! @note Recursive function, only call this from root node.
  void collectGeometryTypes()
  {
    _fixed_size_possible = true;

    if constexpr (not Concept::LeafTreeNode<Node>) {
      forEach(node(), [&](auto& child, auto path) {
        child.collectGeometryTypes();

        if constexpr (not prioryFixedSize()) {
          // properties contained in child nodes are also contained here
          for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim)
            _codim_used[codim] =
              _codim_used[codim] or child.containsCodim(codim);

          for (std::size_t gt = 0; gt < _gt_used.size(); ++gt)
            _gt_used[gt] = _gt_used[gt] or child.containsGeometry(gt);
        }
      });
    }

    // create offset of indices for contained geometry types
    if constexpr (not prioryFixedSize()) {
      for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
        for (const auto& gt : entitySet().indexSet().types(codim)) {
          const auto gt_index = GlobalGeometryTypeIndex::index(gt);
          if (containsGeometry(gt_index))
            (*_gt_entity_offsets)[gt_index + 1] = entitySet().indexSet().size(gt);
        }
        std::partial_sum(begin(*_gt_entity_offsets),
                        end(*_gt_entity_offsets),
                        begin(*_gt_entity_offsets));
        if (not _entity_dof_offsets)
          _entity_dof_offsets = std::make_unique<std::vector<SizeType>>();
        _entity_dof_offsets->assign(_gt_entity_offsets->back() *
                                      std::max<std::size_t>(node().degree(), 1),
                                    0);
      }
    }
  }

  //! Gather sizes for entity sizes on the leaf node from local keys (variable
  //! size)
  //! @note Use this after geometry types have been collected
  //! @note This class additionally checks if sizes change between different
  //! entities, thus, allowing us to know if we can compress variable size data
  //! into fixed size data
  template<class Entity>
  void collectEntitySizes(const Entity& entity, std::vector<SizeType>& gt_cache)
  {
    static_assert(not prioryFixedSize());
    static_assert(Concept::LeafTreeNode<Node>);
    if (_fixed_size_possible)
      std::fill(gt_cache.begin(), gt_cache.end(), GT_UNUSED);

    using FEM = typename Node::Space::Traits::FiniteElementMap;
    constexpr std::size_t fem_dim = FEM::Traits::FiniteElement::Traits::LocalBasisType::Traits::dimDomain;
    constexpr std::size_t fem_codim = EntitySet::dimension - fem_dim;

    const FEM& fem = node().space().finiteElementMap();
    for (std::size_t s = 0; s != entity.subEntities(fem_codim); ++s) {
      const auto& sub_entity = [&]{
        if constexpr (fem_codim == 0)
          return entity;
        else
          return entity.template subEntity<fem_codim>(s);
      }();

      const auto& finite_element = fem.find(sub_entity);
      if (finite_element.type() != entity.type())
        DUNE_THROW(RangeError, "Dune::GeometryType of the local finite element and entity do not match!");
      using FEM = typename Node::Space::Traits::FiniteElementMap;
      using FESwitch =
        FiniteElementInterfaceSwitch<typename FEM::Traits::FiniteElement>;
      const auto& coeffs = FESwitch::coefficients(finite_element);

      const auto& ref_el = referenceElement(sub_entity.geometry());
      for (std::size_t dof = 0; dof != coeffs.size(); ++dof) {
        const LocalKey& key = coeffs.localKey(dof);
        const SizeType gt_index = GlobalGeometryTypeIndex::index(ref_el.type(key.subEntity(), key.codim()));
        const SizeType entity_index = entitySet().indexSet().subIndex(sub_entity, key.subEntity(), fem_codim + key.codim());
        const SizeType index = (*_gt_entity_offsets)[gt_index] + entity_index;
        gt_cache[gt_index] = (*_entity_dof_offsets)[index] =
          std::max<SizeType>((*_entity_dof_offsets)[index], key.index() + 1);
      }
    }

    // as long as we haven't discarded possible fixed size, we try to find
    // out if the seen geometry types have fixed size
    if (_fixed_size_possible) {
      for (std::size_t i = 0; i < gt_cache.size(); ++i) {
        // update unused entries
        if ((*_gt_dof_offsets)[i] == GT_UNUSED)
          (*_gt_dof_offsets)[i] = gt_cache[i];
        // if cache does not match global gt sizes, we need to discard fixed
        // size computations
        if ((*_gt_dof_offsets)[i] != gt_cache[i]) {
          _fixed_size_possible = false;
          break;
        }
      }
    }
  }

  //! Convert size vectors into offset vectors
  //! This class first identifies if fixed size is possible, then accumulate
  //! offsets in the corresponding data structure
  //! @note Recursive function, only call this from root node.
  void accumulateEntityOffsets()
  {
    _block_count = 0;
    if constexpr (Concept::LeafTreeNode<Node>) {
      // if we did't discard fixed size by this point, we can use the
      // fixed size geometry type sizes
      if (_fixed_size_possible) {
        _entity_dof_offsets.reset(); // discard individual entity sizes
        _fixed_size = true;
      }
      // mask out GT_UNUSED for geometry types that really weren't used
      for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
        for (const auto& gt : entitySet().indexSet().types(codim)) {
          auto& size = (*_gt_dof_offsets)[GlobalGeometryTypeIndex::index(gt)];
          if (size == GT_UNUSED)
            size = 0;
          if (_fixed_size)
            _block_count += size * entitySet().size(gt);
        }
      }
      if (not _fixed_size)
        _block_count = std::accumulate(
          begin(*_entity_dof_offsets), end(*_entity_dof_offsets), 0);
    } else {
      // update node properties
      _fixed_size_possible = true;
      forEach(node(), [&](auto& child, auto path) {
        // update sub-tree
        child.accumulateEntityOffsets();
        _fixed_size_possible &= child.fixedSize();
        _max_local_coeff_count += child.maxLocalCount();
      });

      const std::size_t dim = EntitySet::dimension;
      const std::size_t gt_count = GlobalGeometryTypeIndex::size(dim);
      if (_fixed_size_possible) {
        // we need to update gt sizes from children and convert them to offsets
        forEach(node(), [&](auto& child, auto i) {
          for (std::size_t codim = 0; codim <= EntitySet::dimension; ++codim) {
            for (const auto& gt : entitySet().indexSet().types(codim)) {
              const auto gt_index = GlobalGeometryTypeIndex::index(gt);
              const auto gt_offset = gt_index * node().degree() + i;
              const auto cb_count = child.blockCount(gt_index);
              (*_gt_dof_offsets)[gt_offset] = cb_count;
              _block_count += cb_count * entitySet().size(gt);
              if (i != 0)
                (*_gt_dof_offsets)[gt_offset] =
                  (*_gt_dof_offsets)[gt_offset - 1] + cb_count;
            }
          }
        });

        _fixed_size = true;
      } else {
        // no fixed size was possible, save offsets for each entity:
        //   for every entity we already have block count,
        //   then, we just need to carry such count to the next entity value
        SizeType index = 0;
        for (SizeType gt = 0; gt < gt_count; ++gt) {
          if (not containsGeometry(gt))
            continue;
          assert((*_gt_entity_offsets)[gt] <= (*_gt_entity_offsets)[gt + 1]);
          const SizeType entity_count =
            (*_gt_entity_offsets)[gt + 1] - (*_gt_entity_offsets)[gt];
          for (SizeType e_index = 0; e_index < entity_count; ++e_index) {
            SizeType carry = 0;
            forEach(node(), [&](auto& child, auto path) {
              carry += child.blockCount(gt, e_index);
              (*_entity_dof_offsets)[index++] = carry;
            });
            _block_count += containerBlocked() ? (carry != 0) : carry;
          }
        }
      }
    }
  }

  //! Setup ordering for variable size maps
  //! @note Recursive function, only call this from root node.
  void updateVariableSizeOrderings()
  {

    forEachNode(node(), []<class T>(T& node, auto path) {
      if constexpr (not T::prioryFixedSize())
        node.allocateVariableSizeOrdering();
    });

    for (const auto& entity : elements(entitySet())) {
      forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
        if constexpr (not T::prioryFixedSize())
          leaf.collectLeafGeometryTypes(entity);
      });
    }

    collectGeometryTypes();

    { // construct cache outside entity collection to avoid reallocation
      const std::size_t dim = EntitySet::dimension;
      std::vector<SizeType> gt_cache(GlobalGeometryTypeIndex::size(dim), 0);

      for (const auto& entity : elements(entitySet())) {
        forEachLeafNode(node(), [&]<class T>(T& leaf, auto path) {
          if constexpr (not T::prioryFixedSize())
            leaf.collectEntitySizes(entity, gt_cache);
        });
      }
    }
    accumulateEntityOffsets();
  }

private:
  //! Cast to node implementation (Barton–Nackman trick)
  const Node& node() const noexcept { return static_cast<const Node&>(*this); }
  Node& node() noexcept { return static_cast<Node&>(*this); }

  CodimFlag _codim_used;
  std::vector<bool> _gt_used;
  MergingStrategy _merging_strategy;
  std::size_t _max_local_coeff_count, _block_count;
  bool _fixed_size;
  bool _fixed_size_possible;


protected:
  /**
   *  Data for this node may be stored in fixed or variable size form:
   *
   * * Fixed Size:
   *    In this case, all entities of a given geometry type look the same.
   *    Thus, we just need to store the offset between nodes for each geometry
   *    type.
   *
   *    gt_index        ||    cell   || ... ||   vertex  || ... ||
   *    child_index     || 0 | 1 | 2 || ... || 0 | 1 | 2 || ... ||
   *    _gt_dof_offsets || 2 | 3 | 8 || ... || 1 | 2 | 3 || ... ||
   *
   * * Variable Size:
   *    In this case, every entity has potentially different sizes so we have
   *    to store each offset individully. This information is stored in the
   *    `_entity_dof_offsets`. Since grids have a different indexation for
   *    each geometry type, we store an offset for these geometry types in
   *    `_gt_entity_offsets`. This works similarly as the
   *    MultipleCodimMultipleGeomTypeMapper object in dune-grid works. This
   *    allows us to keep everything as packed and cache friendly as possible.
   *
   *    gt_index              || cell                          || vertex    ||
   *    _gt_entity_offsets    || *                             || *         ||
   *                             |                                |
   *                             v                                v
   *    entity_index          ||   cell0   ||   cell1   || ... ||  vertex0  ||
   *    child_index           || 0 | 1 | 2 || 0 | 1 | 2 || ... || 0 | 1 | 2 ||
   *    _entity_dof_offsets   || 2 | 3 | 8 || 0 | 0 | 0 || ... || 1 | 2 | 3 ||
   *
   * @todo Try to use MultipleCodimMultipleGeomTypeMapper for variable size.
   * If the abstraction does not fit here, document why.
   */
  std::shared_ptr<std::vector<SizeType>> _gt_dof_offsets;
  std::shared_ptr<std::vector<SizeType>> _gt_entity_offsets;
  std::shared_ptr<std::vector<SizeType>> _entity_dof_offsets;
};

} // namespace Dune::PDELab::inline Experimental::Impl

#endif // DUNE_PDELAB_BASIS_ORDERING_ENTITY_BASE_HH
